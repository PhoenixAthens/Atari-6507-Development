**Context:[`cleanMem.asm`](https://github.com/PhoenixAthens/Atari-6507-Development/blob/main/cleanMem/cleanMem.asm)**<br>
`Q1::` Why do programmers call the memory positions from `00` to `FF` in RAM as `page 0`?

`A::` Programmers often refer to the memory range from addresses `0x00` to `0xFF` (hexadecimal) as "page 0" because of how memory is organized and addressed in computer systems.

In many computer architectures, memory is divided into fixed-size blocks called "pages" for memory-management purposes. The size of a page can vary, but common sizes are 4KB (4096 bytes) or 8KB (8192 bytes).

The first page of memory, starting from address `0x0000 0000`, is referred to as "page 0". This page covers the address range from `0x0000 0000` to `0x0000 0FFF` (for a 4 KB page size) or `0x0000 1FFF` (for an 8 KB page size).

The hexadecimal range `0x00` to `0xFF` corresponds to the first 256 bytes of memory, which falls within page 0. This range is often used for special purposes, such as:

1. Storing important system data and variables during system boot or initialization
2. Mapping hardware registers and memory-mapped I/O devices.
3. Holding interrupt vector tables or other low-level system data structures.

By referring to this range as "page 0", the programmers can easily identify and distinguish it from other memory pages, which may have different characteristics or purposes.

It's important to note that the specific usage and organization of page 0 can vary depending on the computer architecture, operating system, and programming environment. However, the general concept of referring to the first 256 bytes of memory as "page 0" is a common convention in programming and system development.

---

`Q2::` What does the following Assembly code do?

```asm
  LDA #2
  STA $2B

  LDX $1234
  DEX
```

`A::` Let's go line by line,

1. `LDA #2`, this tells the processor to load (`LD`) the `A` register (`A` refers to the `Accumulator` register) with the literal value `2` (2 here is a base 10 decimal literal).
2. `STA $2B`, this tells the processor to store (`ST`) the value in the `A` register, into the memory location `$2B`.
3. `LDX $1234`, this tells the processor to load (`LD`) whatever value is present in the memory location with address `$1234` into the register `X` (`X` is a general purpose registers, other general purpose registers in 6507 processor include `Y`, and `A`, the `Accumulator`).
4. `DEX`, this tells the processor to decrement the value in the `X` register.

Now something interesting happens when our assembly code is translated into opcodes by the Assembler. The opcodes generated by our Assembler, look something like this:

```asm
  a9 02       ; a9 is the opcode for LDA
  85 2b       ; 85 is the opcode for STA
  ae 34 12    ; ae is the opcode for LDX
  ca          ; ca is the opcode for DEX
```

You see that third line `ae 34 12`, why are we seeing the address `$1234` in this order. Well, remember `big-endian` and `little-endian` processors. In `big-endian`, we go from left to right, representing the most-significant value first. In `little-endian`, on the other hand, we go from right to left, representing the most-significant value on the far right. Since 6502 is a little endian processor, we store the most-significant bits, in this case `12` in the far right, `34` to its left, and so on.

---

_Some Notes for the curious_<br>

In Assembly language,

- we have `load and store instructions`, in 6502 assembly, they look something like this:

```asm
  LDA   ;load the A register
  LDX   ;load the X register
  LDY   ;load the Y register

  STA   ;store the value from A register into a memory location
  STX   ;store the value from X register into a memory location
  STY   ;store the value from Y register into a memory location
```

- we have `arithmetic instructions`, in 6502 assembly, they look something like this:

```asm
  ADC   ;add to the accumulator (with carry)
  SBC   ;subtract from the accumulator (with carry)

  ; There are no instructions to perform multiplication and subtraction in
  ; 6502 processor. If you want to perform multiplication, we do a series of
  ; additions, and a series of subtractions, if we want to perform division!
```

You'll usually see a `CLC` (_clear the carry flag_) instruction before addition instruction `ADC`. Why we'd want to do this? Well, the rationale is pretty easy. To detect if our calculation resulted in a carry-over, we must first clear the carry flag.

And, a `SEC` (_set the carry flag_) instruction before the subtraction instruction `SBC`. Why we'd want to do this? Well, Let's bing it! Alright!! So it goes like this:

In 6502 assembly language, the `SEC` (Set Carry) instruction is used before a subtraction operation to set the carry flag. This might seem counterintuitive, but it's because of how the 6502 processor handles subtraction.

The 6502 processor doesn't actually have a subtraction operation. Instead, it uses a method called _two's complement arithmetic_ to perform subtraction using addition. Here's how it works:

1. To subtract a number, you first take its two's complement, which involves inverting the bits (changing 1s to 0s and vice versa) and then adding 1 to the result.
2. You then add this two's complement to the number from which you want to subtract. The carry flag needs to be set (using `SEC`) before this addition to correctly handle the "borrow" that would occur in a traditional subtraction operation.

So, in a nutshell `SEC` is used to set up the processor for a subtraction operation by ensuring the carry flag is in the correct state for the two's complement addition that the processor will perform.

Q:: Now you might ask what's meaning of this part " The carry flag needs to be set (using `SEC`) before this addition to correctly handle the "borrow" that would occur in a traditional subtraction operation."? Well I asked the same question, so _up-high_!

A:: It goes like this, in traditional subtraction, we "borrow" from the next higher place value when the number we're subtracting is larger than the number we're subtracting from. For example, in the subtraction `100 - 45`, we can't subtract 5 from 0, so we borrow 1 from the tens place, turning it into 10, then 10 - 5 = 5.

In the 6502 processor, this "borrow" concept is inverted. Instead of borrowing 1 when we can't subtract, we "carry" 1 when we can subtract. So, before we do a subtraction, we need to set the carry flag to 1 (using `SEC`) to indicate that we haven't borrowed anything yet.

Then, during the subtraction (which is usually an addition of the two's complement), if the result is less than the original number, the carry flag stays 1, indicating that no "borrow" was needed. But if the result is greater than the original number, it means we've "borrowed" and the carry flag is reset to 0.

So, setting the carry flag before subtraction is like saying "we haven't borrowed anything yet". Then, the subtraction operation checks if a "borrow" is needed and updates the carry flag accordingly.

---

- we have `increment and decrement instructions`, in 6502 assembly, they look something like this:

```asm
  INC   ;increment the value in specified memory address by 1
  INX   ;increment X register's value by 1
  INY   ;increment Y register's value by 1

  DEC   ;decrement the value in specified memory address by 1
  DEX   ;decrement X register's value by 1
  DEY   ;decrement Y register's value by 1
```

One thing to remember about the `increment & decrement instructions` is that they set the processor flags, so if the result of increment or decrement was 0, the `Z` flag in `p` register is set to 1, indicating a zero-result, and 0 otherwise. If the result is negative (the 7th bit, sign-bit turns 1) the `N` flag is `p` register is set to 1, and 0 otherwise.

We also have `JMP` instruction, this acts almost like a `goto`, allowing the control flow to jump to instruction in the specified memory location!

We also have conditional branching instructions, which allow control flow to jump to certain instruction and are executed based on the current state of flags in the `p` register, they go something like this

```asm
  ; in the comments below, "C" refers to the "Carry Flag", "Z" refers to the "Result Zero Flag", "N" refers to "Negative result flag", "V" refers to "Overflow flag"

  BCC   ;Branch on carry clear, i.e. if C == 0
  BCS   ;Branch on carry set, i.e. if C == 1
  BEQ   ;Branch on result equal to 0, i.e. if Z == 1
  BNE   ;Branch on result not equal to 0, i.e., if Z == 0
  BMI   ;Branch on minus, i.e. if N == 1
  BPL   ;Branch on plus, i.e. if N == 0
  BVC   ;Branch on overflow clear, i.e. if V == 0
  BVS   ;Branch on overflow set, i.e. if V == 1
```
