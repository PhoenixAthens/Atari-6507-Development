**Context:[`cleanMem.asm`](https://github.com/PhoenixAthens/Atari-6507-Development/blob/main/cleanMem/cleanMem.asm)**<br>
`Q1::` Why do programmers call the memory positions from `00` to `FF` in RAM as `page 0`?

`A::` Programmers often refer to the memory range from addresses `0x00` to `0xFF` (hexadecimal) as "page 0" because of how memory is organized and addressed in computer systems.

In many computer architectures, memory is divided into fixed-size blocks called "pages" for memory-management purposes. The size of a page can vary, but common sizes are 4KB (4096 bytes) or 8KB (8192 bytes).

The first page of memory, starting from address `0x0000 0000`, is referred to as "page 0". This page covers the address range from `0x0000 0000` to `0x0000 0FFF` (for a 4 KB page size) or `0x0000 1FFF` (for an 8 KB page size).

The hexadecimal range `0x00` to `0xFF` corresponds to the first 256 bytes of memory, which falls within page 0. This range is often used for special purposes, such as:

1. Storing important system data and variables during system boot or initialization
2. Mapping hardware registers and memory-mapped I/O devices.
3. Holding interrupt vector tables or other low-level system data structures.

By referring to this range as "page 0", the programmers can easily identify and distinguish it from other memory pages, which may have different characteristics or purposes.

It's important to note that the specific usage and organization of page 0 can vary depending on the computer architecture, operating system, and programming environment. However, the general concept of referring to the first 256 bytes of memory as "page 0" is a common convention in programming and system development.

---

`Q2::` What does the following Assembly code do?

```asm
  LDA #2
  STA $2B

  LDX $1234
  DEX
```

`A::` Let's go line by line,

1. `LDA #2`, this tells the processor to load (`LD`) the `A` register (`A` refers to the `Accumulator` register) with the literal value `2` (2 here is a base 10 decimal literal).
2. `STA $2B`, this tells the processor to store (`ST`) the value in the `A` register, into the memory location `$2B`.
3. `LDX $1234`, this tells the processor to load (`LD`) whatever value is present in the memory location with address `$1234` into the register `X` (`X` is a general purpose registers, other general purpose registers in 6507 processor include `Y`, and `A`, the `Accumulator`).
4. `DEX`, this tells the processor to decrement the value in the `X` register.

Now something interesting happens when our assembly code is translated into opcodes by the Assembler. The opcodes generated by our Assembler, look something like this:

```asm
  a9 02       ; a9 is the opcode for LDA
  85 2b       ; 85 is the opcode for STA
  ae 34 12    ; ae is the opcode for LDX
  ca          ; ca is the opcode for DEX
```

You see that third line `ae 34 12`, why are we seeing the address `$1234` in this order. Well, remember `big-endian` and `little-endian` processors. In `big-endian`, we go from left to right, representing the most-significant value first. In `little-endian`, on the other hand, we go from right to left, representing the most-significant value on the far right. Since 6502 is a little endian processor, we store the most-significant byte (not bits), in this case `12` in the far right, `34` to its left, and so on.

---

_Some Notes for the curious_<br>

In Assembly language,

- we have `load and store instructions`, in 6502 assembly, they look something like this:

```asm
  LDA   ;load the A register
  LDX   ;load the X register
  LDY   ;load the Y register

  STA   ;store the value from A register into a memory location
  STX   ;store the value from X register into a memory location
  STY   ;store the value from Y register into a memory location
```

- we have `arithmetic instructions`, in 6502 assembly, they look something like this:

```asm
  ADC   ;add to the accumulator (with carry)
  SBC   ;subtract from the accumulator (with carry)

  ; There are no instructions to perform multiplication and subtraction in
  ; 6502 processor. If you want to perform multiplication, we do a series of
  ; additions, and a series of subtractions, if we want to perform division!
```

You'll usually see a `CLC` (_clear the carry flag_) instruction before addition instruction `ADC`. Why we'd want to do this? Well, the rationale is pretty easy. To detect if our calculation resulted in a carry-over, we must first clear the carry flag.

And, a `SEC` (_set the carry flag_) instruction before the subtraction instruction `SBC`. Why we'd want to do this? Well, Let's bing it! Alright!! So it goes like this:

In 6502 assembly language, the `SEC` (Set Carry) instruction is used before a subtraction operation to set the carry flag. This might seem counterintuitive, but it's because of how the 6502 processor handles subtraction.

The 6502 processor doesn't actually have a subtraction operation. Instead, it uses a method called _two's complement arithmetic_ to perform subtraction using addition. Here's how it works:

1. To subtract a number, you first take its two's complement, which involves inverting the bits (changing 1s to 0s and vice versa) and then adding 1 to the result.
2. You then add this two's complement to the number from which you want to subtract. The carry flag needs to be set (using `SEC`) before this addition to correctly handle the "borrow" that would occur in a traditional subtraction operation.

So, in a nutshell `SEC` is used to set up the processor for a subtraction operation by ensuring the carry flag is in the correct state for the two's complement addition that the processor will perform.

Q:: Now you might ask what's meaning of this part " The carry flag needs to be set (using `SEC`) before this addition to correctly handle the "borrow" that would occur in a traditional subtraction operation."? Well I asked the same question, so _up-high_!

A:: It goes like this, in traditional subtraction, we "borrow" from the next higher place value when the number we're subtracting is larger than the number we're subtracting from. For example, in the subtraction `100 - 45`, we can't subtract 5 from 0, so we borrow 1 from the tens place, turning it into 10, then 10 - 5 = 5.

In the 6502 processor, this "borrow" concept is inverted. Instead of borrowing 1 when we can't subtract, we "carry" 1 when we can subtract. So, before we do a subtraction, we need to set the carry flag to 1 (using `SEC`) to indicate that we haven't borrowed anything yet.

Then, during the subtraction (which is usually an addition of the two's complement), if the result is less than the original number, the carry flag stays 1, indicating that no "borrow" was needed. But if the result is greater than the original number, it means we've "borrowed" and the carry flag is reset to 0.

So, setting the carry flag before subtraction is like saying "we haven't borrowed anything yet". Then, the subtraction operation checks if a "borrow" is needed and updates the carry flag accordingly.

(Try understanding the above text in context of subtracting `-45` from `34` and do the calculation as specified above in Binary format!!)

---

- we have `increment and decrement instructions`, in 6502 assembly, they look something like this:

```asm
  INC   ;increment the value in specified memory address by 1
  INX   ;increment X register's value by 1
  INY   ;increment Y register's value by 1

  DEC   ;decrement the value in specified memory address by 1
  DEX   ;decrement X register's value by 1
  DEY   ;decrement Y register's value by 1
```

One thing to remember about the `increment & decrement instructions` is that they set the processor flags, so if the result of increment or decrement was 0, the `Z` flag in `p` register is set to 1, indicating a zero-result, and 0 otherwise. If the result is negative (the 7th bit, sign-bit turns 1) the `N` flag is `p` register is set to 1, and 0 otherwise.

```asm
    JMP ;Jump to another location GOTO
```

We also have `JMP` instruction, this acts almost like a `goto`, allowing the control flow to jump to instruction in the specified memory location!

We also have conditional branching instructions, which allow control flow to jump to certain instruction and are executed based on the current state of flags in the `p` register, they go something like this

```asm
  ; in the comments below, "C" refers to the "Carry Flag", "Z" refers to the "Result Zero Flag", "N" refers to "Negative result flag", "V" refers to "Overflow flag"

  BCC   ;Branch on carry clear, i.e. if C == 0
  BCS   ;Branch on carry set, i.e. if C == 1
  BEQ   ;Branch on result equal to 0, i.e. if Z == 1
  BNE   ;Branch on result not equal to 0, i.e., if Z == 0
  BMI   ;Branch on minus, i.e. if N == 1
  BPL   ;Branch on plus, i.e. if N == 0
  BVC   ;Branch on overflow clear, i.e. if V == 0
  BVS   ;Branch on overflow set, i.e. if V == 1
```

---
Now, let's use what we have learnt so far and use it to write a *loop*. So here's the code to achieve that:
```asm
    ldy #100 ;y = 100
Loop:
    dey      ;y--
    bne Loop
```
Now, let's understand this program line by line!

*First*: `ldy #100`, here we are loading the literal decimal value '100' into the `y` register. (`ldy` is the 6502 assembly instruction to load a value into the `y` register)

*Second*: `Loop:`, this is simply just an alias to a ROM address

*Third*: `dey`, this statment falls under the `Loop` label and will decrement the value stored in the `y` register by 1.

*Fourth*: `bne Loop`, this is the instruction that makes the label `Loop` function like a loop, this instruction `bne Loop` will *branch back to the address stored in label `Loop`* if the `Z` status flag of the `P` register is not set (i.e. if Z == 0)


Something interesting that you might have noticed is that throughout the above explanation we used the term `ROM` address and not `RAM` address! Now, why is that? Well the simple guess would be the fact that Atari 2600 and other similar consoles used ROM Cartridges which stored the game logic, so the address in code would in fact be referring to addresses on that ROM cartridge.

The formal explanation however goes something like this,

In the context of the Atari 2600 and many other game consoles and computers, programs were stored on *ROM Cartridges*. ROM stands for Read-Only Memory, which means the data stored on it can be read but not modified. This is why the program code, including labels like `Loop`, are referring to addresses in ROM.

When the cartridge is inserted into the Atari 2600, the console's hardware maps the ROM on the cartridge to its address space. The 6507 processor in the Atari 2600 then executes the instruction directly from this ROM. This is known as *memory-mapped I/O*, where the device (in this case, the ROM cartridge) is accessed as if it were a part of the main memory.

So, when you define a label like `Loop` in your assembly code, the assembler will replace it with the actual address of that instruction in ROM. When the `bne Loop` instruction is executed, the processor will branch to that address in ROM if the zero flag is not set.

RAM, on the other hand, is used for temporary storage of data that the program might need to modify while it's running. In the case of the Atari 2600, it had a very small amount of RAM (128 bytes) that was used for this purpose. But the actual program code was executed directly from ROM. Hence, we talk about ROM addresses in this context.

----
**Context:[`cleanMem.asm`](https://github.com/PhoenixAthens/Atari-6507-Development/blob/main/cleanMem/cleanMem.asm)**<br>
`Q1::` In the following 6507 assembly code
```asm
  processor 6502

  seg code
  org $F000
```
why do we define the start of our ROM cartridge from address `F000` and not `0000` using the `org $F000`?

`A::` The reason for starting the code at address `$F000` instead of `$0000` in a 6502 assembly program is due to the memory mapping and architecture of the 6502 processor and the systems it was designed for.

The 6502 processor has a 16-bit address bus, which means it can address up to 64 kilobytes (KB) of memory, ranging from $0000 to $FFFF. However, this memory space was typically divided into different sections for different purposes:
1. *Zero Page* ($0000 - $00FF): This area was used for fast access to variables and temporary data due to the zero-page addressing mode of the 6502.
2. *Stack* ($0100 - $01FF): This area was reserved for the system stack.
3. *RAM* ($0200 - $CFFF): This area was used for general-purpose RAM, where program variables and data could be stored.
4. *I/O and System Memory* ($D000 - $EFFF): This area was typically reserved for memory-mapped I/O devices and system firmware.
5. *ROM* ($F000 - $FFFF): This area, also known as the "cartridge space," was reserved

By starting the code at address `$F000`, the programmer was placing their program code in the designated ROM area, which was expected to be mapped to the system's ROM cartridge or other non-volatile memory. This allowed the program code to be executed directly from the ROM without having to be loaded into RAM first.

Additionally, starting the code at `$F000` left the lower memory areas (`$0000 - $EFFF`) available for other purposes, such as system firmware, I/O devices, and RAM for program data and variables.

It's worth noting that while `$F000` was a common starting address for ROM cartridges, some systems or applications might have used different memory mappings or starting addresses for their ROM code. The choice of the starting address depended on the specific system's memory layout and design.

----
**Context:[`cleanMem.asm`](https://github.com/PhoenixAthens/Atari-6507-Development/blob/main/cleanMem/cleanMem.asm)**<br>
`Q2::` Why do we use the value `#$FF` in this instruction `ldx #$FF`? Are we loading the hex-value `$FF` into the `X` register or are we loading the the decimal equivalent of `$FF` into the `X` register? Why didn't we simply write `ldx $FF`? Is the purpose of `#`, to state that we are loading a literal value and distinguish it from the fact that we don't want to store an address?

`A::`

----
**Context:[`cleanMem.asm`](https://github.com/PhoenixAthens/Atari-6507-Development/blob/main/cleanMem/cleanMem.asm)**<br>
`Q3::` We have defined the origin address using `org` as `$4000`, does that mean that the ROM cartridge had 16-bit addressing?

`A::`

----
**Context:[`cleanMem.asm`](https://github.com/PhoenixAthens/Atari-6507-Development/blob/main/cleanMem/cleanMem.asm)**<br>
`Q4::` In context of the following 6502 assembly code, does the stack-pointer refer to the $FF register in RAM or in ROM? (The answer is `RAM`)
```asm
    processor 6502

    seg code    ;
    org $F000   ; Define the code origin at $F000

Start:
    sei         ; Disable interrupts
    cld         ; Disable the BCD decimla math mode
    ldx #$FF    ; Loads the X register with #$FF
    txs         ; Transfer the X register to the Stack pointer
```

`A::`

---
**Context:[`cleanMem.asm`](https://github.com/PhoenixAthens/Atari-6507-Development/blob/main/cleanMem/cleanMem.asm)**<br>
`Q5::` I heard the following

> "The addresses from $00 - $FF includes the TIA chip memory mapping addresses and also the entire RAM of our machine"

What's the purpose of the `TIA` register in Atari? Why is it included in the RAM?

---
**Context:[`cleanMem.asm`](https://github.com/PhoenixAthens/Atari-6507-Development/blob/main/cleanMem/cleanMem.asm)**<br>
`Q6::` What does `zero-page addressing mode of the 6502` mean? How did it benefit the 6502 processor?

`A::` The zero-page addressing mode of the 6502 processor refers to a special mode that allows for faster and more efficient access to a specific region of memory called the "zero-page."

The zero-page is the first 256 bytes of memory, ranging from addresses `$0000` to `$00FF`. This region of memory can be accessed usign a single 8-bit address, rather than the full 16-bit address required for the rest of the memory.

The benefit of the zero-page addressing mode is that it requires fewer clock cycles to fetch and decode the instruction, as well as fewer cycles to access the memory location. This is because the processor only needs to handle an 8-bit address instead of a 16-bit address, which simplifies the addressing logic and reduces the number of operations required.

Here are some specific advantages of the zero-page addressing mode:
1. *Faster execution*: Instructions that use zero-page addressing execute faster than instructions that use other addressing modes, as they require fewer clock cycles.
2. *Smaller code size*: Zero-page addressing instructions use fewer bytes of memory compares to instructions that use other addressing modes, resulting in smaller and more compact code.
3. *Efficient access to variables and temporary data*: The zero page was often used to store frequently accessed variables, temporary data, and function parameters, as accessing this region was faster than accessing other areas of memory.
4. *Compatibility with legacy systems*: The zero-page addressing mode was a carry-over from earlier 8-bit processors, which had a smaller address space. This compatibility allowed for easier porting of code from older systems to the 6502.

While the zero-page addressing mode provided significant performance benefits, it also had a limitation: only 250 bytes of memory could be directly accessed using this mode. However, this limitation was often mitigated by carefully managing the use of the zero page and employing techniques such as page-zero variable reuse or bank-switching (What is bank-switching?) for larger programs.

Overall, the zero-page addressing mode was an important feature of the 6502 processor, contributing to its efficiency and performance, especially in systems with limited memory resources.

---
