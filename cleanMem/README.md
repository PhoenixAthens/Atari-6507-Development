**Context:[`cleanMem.asm`](https://github.com/PhoenixAthens/Atari-6507-Development/blob/main/cleanMem/cleanMem.asm)**<br>
`Q1::` Why do programmers call the memory positions from `00` to `FF` in RAM as `page 0`?

`A::` Programmers often refer to the memory range from addresses `0x00` to `0xFF` (hexadecimal) as "page 0" because of how memory is organized and addressed in computer systems.

In many computer architectures, memory is divided into fixed-size blocks called "pages" for memory-management purposes. The size of a page can vary, but common sizes are 4KB (4096 bytes) or 8KB (8192 bytes).

The first page of memory, starting from address `0x0000 0000`, is referred to as "page 0". This page covers the address range from `0x0000 0000` to `0x0000 0FFF` (for a 4 KB page size) or `0x0000 1FFF` (for an 8 KB page size).

The hexadecimal range `0x00` to `0xFF` corresponds to the first 256 bytes of memory, which falls within page 0. This range is often used for special purposes, such as:

1. Storing important system data and variables during system boot or initialization
2. Mapping hardware registers and memory-mapped I/O devices.
3. Holding interrupt vector tables or other low-level system data structures.

By referring to this range as "page 0", the programmers can easily identify and distinguish it from other memory pages, which may have different characteristics or purposes.

It's important to note that the specific usage and organization of page 0 can vary depending on the computer architecture, operating system, and programming environment. However, the general concept of referring to the first 256 bytes of memory as "page 0" is a common convention in programming and system development.

---

`Q2::` What does the following Assembly code do?

```asm
  LDA #2
  STA $2B

  LDX $1234
  DEX
```

`A::` Let's go line by line,

1. `LDA #2`, this tells the processor to load (`LD`) the `A` register (`A` refers to the `Accumulator` register) with the literal value `2` (2 here is a base 10 decimal literal).
2. `STA $2B`, this tells the processor to store (`ST`) the value in the `A` register, into the memory location `$2B`.
3. `LDX $1234`, this tells the processor to load (`LD`) whatever value is present in the memory location with address `$1234` into the register `X` (`X` is a general purpose registers, other general purpose registers in 6507 processor include `Y`, and `A`, the `Accumulator`).
4. `DEX`, this tells the processor to decrement the value in the `X` register.

Now something interesting happens when our assembly code is translated into opcodes by the Assembler. The opcodes generated by our Assembler, look something like this:

```asm
  a9 02       ; a9 is the opcode for LDA
  85 2b       ; 85 is the opcode for STA
  ae 34 12    ; ae is the opcode for LDX
  ca          ; ca is the opcode for DEX
```

You see that third line `ae 34 12`, why are we seeing the address `$1234` in this order. Well, remember `big-endian` and `little-endian` processors. In `big-endian`, we go from left to right, representing the most-significant value first. In `little-endian`, on the other hand, we go from right to left, representing the most-significant value on the far right. Since 6502 is a little endian processor, we store the most-significant bits, in this case `12` in the far right, `34` to its left, and so on.

---

_Some Notes for the curious_<br>
In Assembly language, <br>

- we have load and store instructions, in 6502 assembly, they look something like this:

```asm
  LDA   ;load the A register
  LDX   ;load the X register
  LDY   ;load the Y register

  STA   ;store the value from A register into a memory location
  STX   ;store the value from X register into a memory location
  STY   ;store the value from Y register into a memory location
```

- we have arithmetic instructions, in 6502 assembly, they look something like this:

```asm

```
